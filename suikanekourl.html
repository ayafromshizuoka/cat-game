<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no">
    <title>猫シンカ - Cat Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background: #fdf5e6; font-family: sans-serif; }
        canvas { display: block; margin: 0 auto; background: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
        #score { position: absolute; top: 20px; left: 20px; font-size: 24px; color: #8b4513; font-weight: bold; }
        /* ゲームオーバー用の赤い点線 */
        #line { position: absolute; top: 150px; left: 50%; transform: translateX(-50%); width: 400px; border-top: 2px dashed #ff4500; pointer-events: none; }
        /* ゲームオーバー時の表示 */
        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.9); padding: 20px; border-radius: 10px; text-align: center; border: 3px solid #8b4513; }
        button { background: #8b4513; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="line"></div>
    <div id="game-over">
        <h2 style="color: #8b4513;">Game Over!</h2>
        <p id="final-score"></p>
        <button onclick="location.reload()">もう一度あそぶ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, World, Bodies, Events, Composite } = Matter;

        const WIDTH = 400;
        const HEIGHT = 600;
        const IMG_BASE_URL ="./"; 
        const LINE_Y = 150; // 点線の高さ

        // 洋子さんが調整した小さめサイズを反映
        const CAT_DATA = [
            { radius: 15, score: 2 }, { radius: 20, score: 4 }, { radius: 30, score: 8 },
            { radius: 40, score: 16 }, { radius: 45, score: 32 }, { radius: 50, score: 64 },
            { radius: 55, score: 128 }, { radius: 60, score: 256 }, { radius: 65, score: 512 },
            { radius: 70, score: 1024 }, { radius: 80, score: 2048 }
        ];

        const engine = Engine.create();
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: { width: WIDTH, height: HEIGHT, wireframes: false, background: '#fff' }
        });
        const runner = Runner.create();
        Render.run(render);
        Runner.run(runner, engine);
        const ground = Bodies.rectangle(WIDTH/2, HEIGHT - 5, WIDTH, 10, { isStatic: true, render: { fillStyle: '#deb887' } });
        const leftWall = Bodies.rectangle(-25, HEIGHT/2, 50, HEIGHT, { isStatic: true });
        const rightWall = Bodies.rectangle(WIDTH + 25, HEIGHT/2, 50, HEIGHT, { isStatic: true });
        World.add(engine.world, [ground, leftWall, rightWall]);

        let score = 0;
        let currentLevel = 0;
        let isClickable = true;
        let gameOverTriggered = false;

        function createCat(x, y, level) {
            const data = CAT_DATA[level];
            const cat = Bodies.circle(x, y, data.radius, {
                restitution: 0.4,
                label: "cat_" + level,
                render: {
                    sprite: {
                        texture: `${IMG_BASE_URL}cat${level + 1}.png`,
                        xScale: (data.radius * 2) / 100,
                        yScale: (data.radius * 2) / 100
                    }
                }
            });
            cat.level = level;
            return cat;
        }

       window.addEventListener("mousedown", (e) => { dropCat(e.clientX); });
       window.addEventListener("touchstart", (e) => { dropCat(e.touches[0].clientX); });
      function dropCat(clientX) {
      if (!isClickable || gameOverTriggered) return;
      isClickable = false;

      const rect = render.canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const newCat = createCat(x, 50, currentLevel);
      World.add(engine.world, newCat);

      setTimeout(() => { 
          currentLevel = Math.floor(Math.random() * 3);
          isClickable = true; 
      }, 800);
      }

        // 進化のロジック
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach((pair) => {
                const { bodyA, bodyB } = pair;
                if (bodyA.label.startsWith("cat_") && bodyA.label === bodyB.label) {
                    const level = bodyA.level;
                    if (level < CAT_DATA.length - 1) {
                        const newX = (bodyA.position.x + bodyB.position.x) / 2;
                        const newY = (bodyA.position.y + bodyB.position.y) / 2;
                        World.remove(engine.world, [bodyA, bodyB]);
                        const nextCat = createCat(newX, newY, level + 1);
                        World.add(engine.world, nextCat);
                        score += CAT_DATA[level + 1].score;
                        document.getElementById("score").innerText = `Score: ${score}`;
                    }
                }
            });
        });

        // ゲームオーバー判定
        Events.on(engine, 'afterUpdate', () => {
            if (gameOverTriggered) return;
            const bodies = Composite.allBodies(engine.world);
            for (let body of bodies) {
                if (body.label.startsWith("cat_") && body.position.y < LINE_Y && body.velocity.y < 0.1) {
                    // 落下中でない猫がラインを超えたら終了
                    gameOverTriggered = true;
                    document.getElementById("final-score").innerText = `最終スコア: ${score}`;
                    document.getElementById("game-over").style.display = "block";
                    break;
                }
            }
        });
    </script>
</body>

</html>







